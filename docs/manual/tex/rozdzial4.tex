	\newpage
\section{Implementacja}		%4
%Opisać implementacje algorytmu/programu. Pokazać ciekawe fragmenty kodu
%Opisać powstałe wyniki (algorytmu/nrzędzia)

\subsection{Implementacja Algorytmu obliczania $\pi$}

Algorytm zaimplementowany jest w funkcji \texttt{getPi()}, pokazanej na listingu nr.~\ref{lst:getpi} zawartej w \texttt{main.cpp}.

\begin{lstlisting}[caption=Funkcja \texttt{getPi()}, label={lst:getpi}, language=C++]
double getPi(const size_t steps, const size_t threads) {                               
	long double deltax { 1. / steps };                                               
                                                                                     
	if(deltax > 1) {                                                                 
		std::println("Rectangle width should be smaller than 1");                    
		return -1;                                                                   
	}                                                                                
                                                                                     
	if(threads == 0) {                                                               
		std::println("Threads should be a non-zero value");                          
		return -1;                                                                   
	}                                                                                
                                                                                     
	double sum = 0.;                                                                 
		                                                                             
	auto calculate = [&](const long double start, const long double end) {           
		long double localSum = 0.;                                                   
		for(long double i {start}; i < end; i+= deltax) {                            
			localSum += sqrt(1 - i * i) * deltax;                                    
		}                                                                            
                                                                                     
		sum += localSum;                                                             
	};                                                                               
                                                                                     
	std::vector<std::thread> threadPool;                                             
	threadPool.reserve(threads);                                                     
                                                                                     
	for(int i = 0; i < threads; i++) {                                               
		threadPool.push_back(std::thread([&, i] {                                    
			calculate(                                                               
				(1. / static_cast<double>(threads)) * i,                             
				(1. / static_cast<double>(threads)) * (i + 1)                        
			);                                                                       
		}));                                                                         
                                                                                     
	}                                                                                
                                                                                     
	for(auto &thread : threadPool) {                                                 
		thread.join();                                                               
	}                                                                                
                                                                                     
	return sum * 4;                                                                  
}                                                                                    
\end{lstlisting}

Na linijce nr.~1 zawarta jest deklaracja funkcji \texttt{getPi()}. Parametr \texttt{steps} określa gęstość prostokątów w ćwiartce, czyli dokładność obliczeń. Parametr \texttt{threads} natomiast, określa liczbę wątków jaka ma być używana podczas działania algorytmu. W linijce nr.~2, parametr \texttt{deltax} to szerokość poszczególnego prostokąta. W linijce nr.~4 i nr.~9 sprawdzana jest poprawność parametrów. W linijce nr.~14 zadeklarowana jest zmienna \texttt{sum}, która ma przechowywać sumę pól prostokątów. W linijce nr.~16 zadeklarowana jest funkcja lambda \texttt{calculate()}, która oblicza sumę pól prostokątów dla danego przedziału. Przedział określony jest przez parametry \texttt{start} i \texttt{end}. Na końcu lambdy, po zsumowaniu pól zmienna \texttt{localSum} dodawana jest do zmiennej \texttt{sum} zbieranej przez referencję. Od linijek nr.~25-34 tworzony jest wektor \texttt{threadPool} i wypełniany jest on wątkami, które po stworzeniu wywołują lambdę \texttt{calculate()}. Na końcu, w linijkach nr.~38-40, czekamy na zakończenie wszystkich wątków przy użyciu metody \texttt{.join()}. Blokuje ona główny wątek aż wykonywanie odpowiedniego wątku się nie zakończy. Na końcu, zwracamy $4 \times \texttt{sum}$, czyli pole, a dlatego że przyjęte jest, że $r = 1$, jest to $\pi$.
